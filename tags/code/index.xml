<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>code on Shallow and Pedantic</title><link>https://lutzky.net/tags/code/</link><description>Recent content in code on Shallow and Pedantic</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 14 Mar 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://lutzky.net/tags/code/index.xml" rel="self" type="application/rss+xml"/><item><title>PiTemp</title><link>https://lutzky.net/2021/03/14/pitemp/</link><pubDate>Sun, 14 Mar 2021 00:00:00 +0000</pubDate><guid>https://lutzky.net/2021/03/14/pitemp/</guid><description>An adventure with Raspberry Pi, Golang, and small displays.</description></item><item><title>Seaplane - Github with a non-programmer</title><link>https://lutzky.net/2015/05/30/seaplane/</link><pubDate>Sat, 30 May 2015 00:00:00 +0000</pubDate><guid>https://lutzky.net/2015/05/30/seaplane/</guid><description>When I helped a non-programmer friend with some code for psychology research, and how we avoided using Matlab.</description></item><item><title>FakeFile</title><link>https://lutzky.net/2014/07/02/fakefile/</link><pubDate>Wed, 02 Jul 2014 00:00:00 +0000</pubDate><guid>https://lutzky.net/2014/07/02/fakefile/</guid><description>A tiny python library for faking out filesystem operations for tests.</description></item><item><title>Fun with file descriptor leaks</title><link>https://lutzky.net/2014/06/22/fun-with-file-descriptor-leaks/</link><pubDate>Sun, 22 Jun 2014 00:00:00 +0000</pubDate><guid>https://lutzky.net/2014/06/22/fun-with-file-descriptor-leaks/</guid><description>How file descriptor leaks are causing your processes to stick around longer than they should.</description></item><item><title>Weird permission issues with tvnamer</title><link>https://lutzky.net/2014/01/05/investigate/</link><pubDate>Sun, 05 Jan 2014 00:00:00 +0000</pubDate><guid>https://lutzky.net/2014/01/05/investigate/</guid><description>Distinguishing &lt;!-- raw HTML omitted -->EPERM&lt;!-- raw HTML omitted --> vs &lt;!-- raw HTML omitted -->EACCESS&lt;!-- raw HTML omitted -->, and how that helps debug file manipulation scripts.</description></item><item><title>Startup times</title><link>https://lutzky.net/2013/12/11/startup-times/</link><pubDate>Wed, 11 Dec 2013 00:00:00 +0000</pubDate><guid>https://lutzky.net/2013/12/11/startup-times/</guid><description>Starting new java processes in your scripts considered harmful. Let&amp;rsquo;s compare &amp;ldquo;hello world&amp;rdquo; startup times for different languages.</description></item><item><title>Asserting string equality</title><link>https://lutzky.net/2013/12/02/asserting-string-equality/</link><pubDate>Mon, 02 Dec 2013 00:00:00 +0000</pubDate><guid>https://lutzky.net/2013/12/02/asserting-string-equality/</guid><description>When comparing long strings in unit tests, make sure your assertion failures give you useful output.</description></item><item><title>Test-driven procrastination</title><link>https://lutzky.net/2013/12/01/test-driven-procrastination/</link><pubDate>Sun, 01 Dec 2013 00:00:00 +0000</pubDate><guid>https://lutzky.net/2013/12/01/test-driven-procrastination/</guid><description>How being lazy and procrastinating led me to adopt test-driven development before I realized it.</description></item><item><title>Multiple library versions</title><link>https://lutzky.net/2013/05/15/multiple-library-versions/</link><pubDate>Wed, 15 May 2013 00:00:00 +0000</pubDate><guid>https://lutzky.net/2013/05/15/multiple-library-versions/</guid><description>Working with vendor code in C can get very tricky, especially when you except breaking changes to occur. Especially when you have multiple binaries depending on that vendor code, updating at different times, necessitating different live versions. Let&amp;rsquo;s explore.
Introduction Assume you&amp;rsquo;re working with an external vendor, who is providing you with code for a wonderful function getFoo:
// foo.h version 1.2.3 int getFoo(); // foo.c version 1.2.3 int getFoo() { sleep(1000); // TODO improve performance return 42 } You use this function in many of your products - for example, in your best-selling barApp application:</description></item><item><title>Translationese</title><link>https://lutzky.net/2013/03/24/translationese/</link><pubDate>Sun, 24 Mar 2013 00:00:00 +0000</pubDate><guid>https://lutzky.net/2013/03/24/translationese/</guid><description>As part of my M.Sc. studies, I&amp;rsquo;ve recently completed a small laboratory project in natural language processing. I&amp;rsquo;ve learned quite a bit from it, and had a chance to use a few of my favorite technologies.
The project was coded in Python, which is not my favorite programming language - Ruby is. However, since Python is more popular at my workplace, and seems to have a richer ecosystem around it (sometimes, at any rate), I&amp;rsquo;ve grown to love it almost as much over the years.</description></item><item><title>Three things I didn't know Ruby does</title><link>https://lutzky.net/2008/07/25/three-things-i-didnt-know-ruby-does/</link><pubDate>Fri, 25 Jul 2008 00:00:00 +0000</pubDate><guid>https://lutzky.net/2008/07/25/three-things-i-didnt-know-ruby-does/</guid><description>Edit: I was misled!
Illustrated here. Hints below.
&amp;gt;&amp;gt; def inspect_x_and_y(x,y); puts &amp;quot;x: %p, y: %p&amp;quot; % [x, y]; end =&amp;gt; nil &amp;gt;&amp;gt; inspect_x_and_y(y={&amp;quot;hello&amp;quot; =&amp;gt; &amp;quot;world&amp;quot;},x=[1,2,3]) x: {&amp;quot;hello&amp;quot;=&amp;gt;&amp;quot;world&amp;quot;}, y: [1, 2, 3] The bits I didn&amp;rsquo;t know about:
&amp;quot;Format strings using a %% sign, %s, %s!&amp;quot; % [ &amp;quot;just like in python&amp;quot;, &amp;quot;but with arrays&amp;quot; ] The %p formatting character is the same as inspect. You can call methods with method_name(param2=val2, param1=val1), also like in python.</description></item><item><title>Valgrind Fail</title><link>https://lutzky.net/2008/06/11/valgrind-fail/</link><pubDate>Wed, 11 Jun 2008 00:00:00 +0000</pubDate><guid>https://lutzky.net/2008/06/11/valgrind-fail/</guid><description>I neglected to post this here somehow, it&amp;rsquo;s about a month old by now&amp;hellip;
Screenshot lost in the mist of time&amp;hellip; shows a program segfaulting, and then working properly when run within valgrind.
The problem turned out to be an imprecise (false-positve) comparison operator implemented for a class used as a hash key. God, I hate C++.</description></item><item><title>Faster Languages</title><link>https://lutzky.net/2008/04/16/faster-languages/</link><pubDate>Wed, 16 Apr 2008 00:00:00 +0000</pubDate><guid>https://lutzky.net/2008/04/16/faster-languages/</guid><description>Due to an exercise in an AI course, I&amp;rsquo;m forced to confront an old nemesis - C++. Part of the reason is that the exercise contains a time-limited tournament, and the code needs to run very quickly. Another reason is, I guess, the fact that C++ serves as a sort of lowest common denominator in the course (which used, by the way, to be taught in LISP, along with the language).</description></item><item><title>On Threading vs. Processing</title><link>https://lutzky.net/2007/10/13/on-threading-vs-processing/</link><pubDate>Sat, 13 Oct 2007 00:00:00 +0000</pubDate><guid>https://lutzky.net/2007/10/13/on-threading-vs-processing/</guid><description>Writing multi-threaded applications in Python is often a headache because of the Global Interpreter Lock - only one Python thread can run at any given moment, which makes multi-threading useful only in the case where all modules but one actually run C code. However, thanks to the impressive new Python Magazine, I&amp;rsquo;ve stumbled across a package called processing, paraphrasing python&amp;rsquo;s built-in threading package. Essentially, the package provides an API identical to Python&amp;rsquo;s threading, but uses processes and pipes (or other mechanisms on non-posix operating systems) instead.</description></item><item><title>Exception handling, decorators, and python</title><link>https://lutzky.net/2007/09/16/exception-handling-decorators-and-python/</link><pubDate>Sun, 16 Sep 2007 00:00:00 +0000</pubDate><guid>https://lutzky.net/2007/09/16/exception-handling-decorators-and-python/</guid><description>Lately I&amp;rsquo;ve been working on a project that has me using DBus a lot. After trying to figure out how to work DBus with C, and seeing how easy it is to do in Python, we figured we&amp;rsquo;d try to use embedded Python to do this. Fortunately, it&amp;rsquo;s very simple to use - especially thanks to this guide.
It later turned out to be much easier to do in C, as described in Faster Languages.</description></item><item><title>IPython</title><link>https://lutzky.net/2007/03/04/ipython/</link><pubDate>Sun, 04 Mar 2007 00:00:00 +0000</pubDate><guid>https://lutzky.net/2007/03/04/ipython/</guid><description>The more I use Python, the nicer it becomes. I&amp;rsquo;m currently working on a project for a course, which involves somewhat heavy-duty database and algorithm work. Python is my language of choice for it - let&amp;rsquo;s hope it works out well.
In the meantime, I&amp;rsquo;ve found a really nice python shell called iPython (available in apt) - it adds a bunch of stuff to the python shell which I sorely missed from irb - autocompletion, auto-indentation, and - it seems - adds a whole lot more.</description></item><item><title>Really liking the whole Python thing</title><link>https://lutzky.net/2007/02/25/really-liking-the-whole-python-thing/</link><pubDate>Sun, 25 Feb 2007 00:00:00 +0000</pubDate><guid>https://lutzky.net/2007/02/25/really-liking-the-whole-python-thing/</guid><description>I&amp;rsquo;ve converted my Antigibberish script1 (converts &amp;ldquo;broken hebrew&amp;rdquo; into proper hebrew, useful for sent-offline ICQ messages) to Python&amp;hellip; it&amp;rsquo;s quite a nice language, and the interpreter is FAST! I&amp;rsquo;m really torn between it and Ruby :(
Used to have a copy of antigibberish.py, but it&amp;rsquo;s been lost in the mists of time. It used to do the equivalent of this:
iconv -f utf-8 -t iso8859-1 | iconv -f iso8859-8 -t utf-8 &amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>3D effects for coders?</title><link>https://lutzky.net/2007/01/25/3d-effects-for-coders/</link><pubDate>Thu, 25 Jan 2007 00:00:00 +0000</pubDate><guid>https://lutzky.net/2007/01/25/3d-effects-for-coders/</guid><description>My new work desktop has a GeForce 4 MX, so I naturally installed Beryl on it. The graphics card has relatively little RAM, so it finds handling my 1280x1024 resolution difficult when additional texture memory is needed - so using something like Firefox really slows it down when Beryl is activated, making me keep it off most of the time. However, for coding, I&amp;rsquo;m finding that Beryl is very useful - it actually helps me that the code windows are transparent, so that I can see what&amp;rsquo;s underneath them, and the &amp;ldquo;Expose&amp;rdquo; effect still leaves text legible, which is great for reading off a lot of terminals at once.</description></item><item><title>As for Python</title><link>https://lutzky.net/2007/01/23/as-for-python/</link><pubDate>Tue, 23 Jan 2007 00:00:00 +0000</pubDate><guid>https://lutzky.net/2007/01/23/as-for-python/</guid><description>Myself, I&amp;rsquo;m a Ruby hacker. I send everyone within earshot to TryRuby, code my sites using Rails, am surprised that I&amp;rsquo;m using a php-based blog&amp;hellip; you get the picture. Ruby is sometimes called the Japanese Python, and comparisons are inevitable. I know very little about Python, but I do know that&amp;hellip;
It has a larger community More GUI applications are written in it More bindings are available for it Its interpreter is much faster Not a far inferior language Ruby certainly does have its advantages over it - trivial class expansion, extremely concise syntax, seemingly better-suited for heavy usage of closures, and Matz.</description></item></channel></rss>